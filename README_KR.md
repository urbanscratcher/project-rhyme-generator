# 라임 생성기

2024년 1월

데이터 구조 및 알고리즘 과제를 위해 작성된 개인 프로젝트로, 발음을 기반으로 라임을 생성하는 프로그램입니다.

## 시연

<video src="https://github.com/urbanscratcher/project-rhyme-generator/assets/17016494/af613744-67bf-42ae-9101-3ee9beb33e85" controls ></video>


## 알고리즘 요약

이 알고리즘은 단어의 음성적 라임을 위한 파싱과 검색, 두 단계로 나눌 수 있습니다.
1. **파싱**: 사용자가 단어를 입력하면 알고리즘은 이를 모음과 자음과 같은 음소로 분해합니다.
2. **검색**: 음성 단어 사전에서 일치하는 단어를 찾습니다. 실제 검색은 각 단어의 끝부분의 음소부터 시작하며, 전체 사전에서 가장 유사한 문자 덩어리를 찾습니다. 일치하는 항목이 발견되면 해당 단어가 표시됩니다.

## 알고리즘 설명

- 일반적으로 생각하는 "라임(rhyme)"이라고 하면, 끝 소리가 비슷한 단어들을 생각할 수 있습니다.
- 이러한 라임을 생성하기 위해 먼저 모든 단어를 음소 단위로 분해하고, 모음과 자음을 구분해야 합니다. 이를 'phonetic parsing(음성 파싱)'이라고 합니다. 미리 아주 많은 단어를 대상으로 음성 파싱을 하고, 각 단어마다 각자의 음소를 가진 일종의 음성 사전을 만듭니다.
- 그 후, 사용자가 단어를 입력하면 시스템이 이를 기억합니다. 알고리즘은 이 단어를 분해해 끝 부분의 음소를 파악합니다. 여기서는 모음이 라임의 기준점으로 작용한다고 가정해 마지막 모음과 자음 소리를 찾습니다.
- 알고리즘은 단어의 끝에서부터 음소를 검색하고, 모음을 발견할 때까지 계속 스캔합니다. 예를 들어 'cat'이라는 단어의 경우 끝 음소가 'æt'라고 식별합니다. 그런 다음 이 소리를 사전의 소리와 비교하여 'hat', 'mat', 'sat'와 같은 비슷한 끝 소리를 가진 단어를 찾습니다.
- 이 과정은 사전의 모든 단어에 대해 반복되며, 목록으로 저장됩니다. 모든 단어를 살펴본 후 알고리즘은 최종 목록을 출력합니다.
- 그러나 결과 수가 너무 적으면(여기서는 5개 미만일 경우), 일치하는 음소를 늘려 다시 검색합니다.
- 요약하면, 이 프로그램은 총 10 단계로 구성됩니다:
   1) 사전 데이터 준비
   2) 입력 받기
   3) 단어 음소 식별
   4) 사전에서 일치하는 음소 검색
   5) 라임 목록에 저장
   6) 4~5를 반복해 모든 단어에 대해 검색
   7) 라임 목록 최종화
   8) 기준에 따라 추가 검색 결정
   9) 결과 출력
   10) 시스템 종료

## 전체 소스 코드 구조

- 이 대규모 프로젝트를 한눈에 정리하기 위해 파트를 아래와 같이 나눴습니다. 함수형 프로그래밍 원칙을 일부 적용했습니다.
- 8단계에서 프로그램은 두 가지 주요 함수, 1) 데이터 준비와 2) 입력 처리 및 검색을 호출하여 시작합니다.

1. 스택 클래스
   - 음소 시퀀스를 관리하기 위한 기본 스택 데이터 구조를 구현합니다.
2. 파일 읽기 및 데이터 준비
   - util.promisify를 사용하여 파일을 비동기적으로 읽습니다.
   - 음성 사전, 음성 기호, 단어 목록 파일을 읽어 기본 사전 데이터를 준비합니다.
3. 데이터 구조
   - phonemesDictArray: 헤드워드와 해당 음소 스택의 배열.
   - vowelSymbolsArray: 모음 기호 배열.
   - rhymeDictArray: 헤드워드, 라임 문자열 및 음소 수의 배열.
4. 서브루틴 함수
   - splitTextlines, splitTabs, getUserInput, excludeElement와 같은 유틸리티 함수를 포함합니다.
5. 1단계 절차 함수
   - 주로 배열을 처리하는 함수로, makePhonemesDictionary, makeWordlist, makeSymbolsDictionary 등이 있습니다.
   - identifyRhyme: 주어진 음소 스택의 라임 문자열을 결정합니다.
   - getMatchedRhymeDicts: 라임 문자열과 음소 수를 기반으로 라임 사전을 필터링합니다.
   - getMeaningfulWords: 일치하는 라임 사전을 기반으로 의미 있는 단어를 필터링합니다.
6. 2단계 절차 함수
   - 주로 1단계 함수를 호출하는 고수준 함수로, getPhonemesDictionary, getWordlist, getSymbolsDictionary, getVowelSymbols, makeRhymeDictionary 등이 있습니다.
7. 3단계 절차 함수
   - 데이터 준비 및 검색 프로세스를 처리하는 주요 절차로, prepareData, processUserInput, setSearchParams, loopSearch, getSearchedWords, getPhonemesOf, getMoreSearchedWords, printOutput, showResult, searchMoreOrEnd 등이 있습니다.
8. 실행
   - prepareData를 호출하여 데이터 구조를 초기화합니다.
   - processSearch를 호출하여 사용자 입력을 받고, 라임 단어를 검색하고, 결과를 표시합니다.

## 사용된 데이터 구조 목록

### 비원시 데이터 구조

1. 배열
   - 일반적으로 배열은 데이터 컬렉션을 저장하고 조작하는 데 사용됩니다. JavaScript 코드에서는 동적 배열을 사용하여 배열을 구현하며, 이는 요소가 추가되거나 제거될 때 유연하게 크기를 조절할 수 있습니다. 이는 음성 사전에서 각 단어의 음소와 같이 크기가 변하는 데이터를 효율적으로 처리하는 데 중요합니다. 또한, 배열을 사용하면 검색 과정에서 접근이 용이합니다.
2. 스택
   - 스택은 JavaScript에서 동적 배열을 사용하여 'Stack' 클래스를 생성함으로써 구현됩니다. 스택은 음성 라임 문자열을 만들기 위해 사용됩니다. LIFO(Last In, First Out) 특성은 라임을 식별하기 위해 마지막 모음 음소를 찾는 과정과 잘 맞습니다. 저는 이를 위해 push 및 pop 메서드를 사용합니다.

### 원시 데이터 구조

1. 정수
   - 정수는 단어의 음소 수 또는 라임 사전의 음소 수와 같은 개수를 나타내는 데 사용됩니다. JavaScript의 숫자는 이러한 카운팅 목적에 적합하고 유연합니다.
2. 문자열
   - 문자열은 단어, 음소 및 라임 문자열을 저장하는 데 사용됩니다. 문자열은 텍스트 데이터를 표현하는 데 기본적이며, 단어 조작, 비교 및 음성 패턴 식별 작업에 적합합니다.
3. 부울
   - 부울은 라임을 찾았는지 여부나 추가 검색 반복이 필요한지 여부를 확인하는 논리 조건에 사용됩니다. 이는 특정 작업의 성공 또는 실패에 따라 결정을 내리는 간단하고 효과적인 방법을 제공합니다.
4. 정의되지 않음 (Undefined)
   - JavaScript에서 undefined는 값의 부재를 나타내는 데 사용됩니다. 이는 특정 데이터가 기대되지만 존재하지 않을 수 있는 경우를 처리하는 데 사용됩니다. 예를 들어, 입력 단어의 음소 스택이 사전에서 발견되지 않으면 함수는 undefined를 반환할 수 있습니다.

## 한계점 및 개선 방안

1. 여러 모음 소리의 라임 고려 부족

- 한계점: 현재 구현은 마지막 모음 소리 하나만으로 라임을 식별한다고 가정하여, 여러 모음이나 음절이 라임에 기여하는 경우를 다루지 못할 수 있습니다.
- 개선 방안:
  라임 식별 알고리즘을 여러 모음을 고려하도록 개선하면 더 포괄적인 라임 매칭이 가능합니다. 그러나 데이터가 복잡해질수록 이를 출력하는 방법도 고려해야 합니다.

2. 위치 고려 부족 (예: catXXX, XXXcatXXX)

- 한계점: 알고리즘은 단어 내 라임 소리의 위치 변형을 고려하지 않아 특정 라임 패턴을 놓칠 수 있습니다.
- 개선 방안:
  라임 식별 알고리즘을 수정하여 단어 내 라임 소리의 다양한 위치를 인식하고 고려할 수 있도록 해야 합니다.

3. CMU 사전의 한계
   - 한계점: 알고리즘은 CMU 발음 사전이라는 기성 사전에 의존하므로, 사람들에게 적절한 라임을 찾지 못할 수 있습니다. 이 사전은 제한된 음소 기호 집합을 통해 발음을 매핑하지만, 항상 이 규칙에 예외가 있을 수 있습니다. 사전이 잘못된
